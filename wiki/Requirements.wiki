#summary Project vision and requirements.
#labels Phase-Requirements

= Background = 

The Nuclear project sprung from a discussion over at the [https://bb.linuxsampler.org/viewtopic.php?f=5&t=101 LinuxSampler forum].

Nuclear is neither a synthesizer nor a sampler. It's beyond that. Instead it let you define new synthesizers, samplers and effects which is called _engines_. The vision is to give virtual instrument makers and plugin developers a powerful tool to create instruments without being limited by a single synthesizer/sample player or bogged down in implementation details common to all virtual instruments.

Originally the idea was to create a single integrated application that both engine creators and end-users would use. An engine maker would use the built in GUI editors to create DSP blocks and connect them together in a processing graph. The DSP and processor graph declarations would be stored in platform independent formats. When a user loaded the engine all the DSP declarations would be compiled natively as modules and the processing graph would be built dynamically from the engine declaration file. This would require the end user having GCC installed and properly configured to be used by the application.

The revised idea is to create a framework to generate code from DSP and engine declarations that will be compiled and linked as a native library. The intended audience is developers who wish to create sample players, synthesizers and effects using a declarative method. To the end-user all hosts and engines appear and are used just like regular applications or plugins.

= Required Features =

  * Being able to create:
    * software synthesizers;
    * sample players;
    * effects and filters.
  * Output the engine as;
    * [http://jackaudio.org JACK] application;
    * [http://python.org Python] module;
    * [http://dssi.sourceforge.net DSSI] plugin;
    * [http://lv2plug.in LV2] plugin;
    * [http://www.steinberg.net VST/VSTi] plugin;
    * [http://developer.apple.com/documentation/MusicAudio/Conceptual/AudioUnitProgrammingGuide/ Audio Unit] plguin;
    * [http://www.digidesign.com RTAS] plugin.
  * DSP blocks are declared in the [http://faust.grame.fr/ FAUST] language.
  * Creating engines by interconnecting DSP blocks as nodes in a processing graph.
  * [Oversampling Oversampling] of local portions of the graph.
  * Automatic handling of [Polyphony polyphony].
  * [Grouping Grouping] of nodes for reuse to create custom DSP routines from basic building blocks without needing to code.
  * Use [http://opensoundcontrol.org OpenSound Control] to control the engine, voices and even individual nodes. Inspired by the [http://stud3.tuwien.ac.at/~e0725639/OSC-SYN.txt OSC 'SYN' namespace] proposal.
  * Ability to view the information stream going through any connection via various means (oscilloscope, spectral display, numeric display, etc.)
  * Allowing instrument makers to create their own GUIs for their instruments.

= Example Projects =

Example projects to be built with Nuclear serving as test cases:

  * _Simple polyphonic synth_. The simplest possible test case. Create a simple polyphonic synth with a LFO modulated oscillator.
  * _SFZ sample player_. Advanced test case. Require streaming sample playback.
  * _Reaktor like application_. Similar to the original Nuclear plan but without the need for compilation by GCC to build instruments. Let the user create and edit a processing graph, use a prebuilt standard library of blocks and write new interpreted DSP blocks.
  * _Guitar Rig like application_. Not an instrument, but an amplifier/cabinet simulator and effect rack. Test case for modeling of non-linear behavior.