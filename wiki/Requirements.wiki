#summary Project vision and requirements.
#labels Phase-Requirements,Featured

= Background = 

The Nuclear project sprung from a discussion over at the [https://bb.linuxsampler.org/viewtopic.php?f=5&t=101 LinuxSampler forum].

Nuclear is neither a synthesizer nor a sampler. It's beyond that. Instead it let you define new synthesizers, samplers and effects which is called _engines_. The vision is to give virtual instrument makers and plugin developers a powerful tool to create instruments without being limited by a single synthesizer/sample player or bogged down in implementation details common to all virtual instruments.

Originally the idea was to create a single integrated application that both engine creators and end-users would use. An engine maker would use the built in GUI editors to create DSP blocks and connect them together in a processing graph. The DSP and processor graph declarations would be stored in platform independent formats. When a user loaded the engine all the DSP declarations would be compiled natively as modules and the processing graph would be built dynamically from the engine declaration file. This would require the end user having a compiler and build environment installed and properly configured to be used by the application.

The revised idea is to create a framework to generate code from DSP block and engine [http://en.wikipedia.org/wiki/Declarative_programming declarations] that will be compiled and linked as a native library. The intended audience is developers who wish to create sample players, synthesizers and effects using a declarative method. To the end-user all hosts and engines appears and are used just like regular applications or plugins.

= Features =

  * Being able to create:
    * software synthesizers;
    * sample players;
    * effects and filters.
  * Output the engine as:
    * [http://jackaudio.org JACK] application;
    * [http://lv2plug.in LV2] plugin.
  * Using [http://faust.grame.fr/ FAUST] for DSP development.
  * Creating engines by interconnecting DSP blocks as nodes in a processing graph:
    * processing graphs are declared in a XML schema;
    * [Oversampling oversampling] of local portions of the graph;
    * [Grouping grouping] of nodes for reuse to create custom DSP routines from basic building blocks without needing to code.
  * Scripting based on [http://opensoundcontrol.org OpenSound Control]. Inspired by the [http://stud3.tuwien.ac.at/~e0725639/OSC-SYN.txt OSC 'SYN' namespace] proposal.
  * Develop good looking custom GUIs for instruments and effects.
  * An [IntegratedDevelopmentEnvironment integrated development environment] for coding DSPs with FAUST, designing custom engine GUIs and visually program the processor graph.
  * Use [http://www.cmake.org/Wiki/CMake CMake] for build automation of the engines.

= Example Projects =

Example projects to be built with Nuclear serving as test cases:

  * _Simple polyphonic synth_. The simplest possible test case. Create a simple polyphonic synth with a LFO modulated oscillator.
  * _SFZ sample player_. Advanced test case. Require streaming sample playback.
  * _[KeyFrameParameterization Keyframe synth]_.
  * _Reaktor like application_. Similar to the original Nuclear plan but without the need for compilation by GCC to build instruments. Let the user create and edit a processing graph, use a prebuilt standard library of blocks and write new interpreted DSP blocks.
  * _[Uranium]_. Not an instrument, but an amplifier/cabinet simulator and effect rack. Test case for modeling of non-linear behavior.

= See Also =

  * [Design]