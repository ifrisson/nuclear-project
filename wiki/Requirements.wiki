#summary Project vision and requirements.
#labels Phase-Requirements

= Background = 

The Nuclear project sprung from a discussion over at the [https://bb.linuxsampler.org/viewtopic.php?f=5&t=101 LinuxSampler forum].

Nuclear is neither a synthesizer nor a sampler. It's beyond that. Instead it let you define new synthesizers, samplers and effects which is called _engines_ that it will provide hosting for. The vision is to give virtual instrument makers and plugin developers a powerful tool to create instruments without being limited by a single synthesizer/sample player or bogged down in implementation details common to all virtual instruments.

Originally the idea was to create a single integrated application that both engine creators and end-users would use. An engine maker would use the built in GUI editors to create DSP blocks and connect them together in a processing graph. The DSP and processor graph declarations would be stored in platform independent formats. When a user loaded the engine all the DSP declarations would be compiled natively as modules and the processing graph would be built dynamically from the engine declaration file. This would require the end user having GCC installed and properly configured to be used by the application.

The revised idea is to create a framework to generate code from DSP and engine declarations that is compiled and linked as a native library. The intended audience is developers who wish to create sample players, synthesizers and effects using a declarative method. To the end-user all hosts and engines is used just like regular applications or plugins.

= Required Features =

 * Output the engine as a JACK application, a Python module or as a DSSI, LV2, VSTi, Audio Unit or RTAS plugin.
 * Easy creation of engines by interconnecting basic DSP blocks in a processing graph.
 * Oversampling of local portions of the graph
 * The ability to create new processing blocks using FAUST, C++, Python, and visually using basic DSP building blocks
 * For nodes of the engine to be able to read-access external control data, such as MIDI data or the master clock, at the whim of the engine creator.
 * The ability to view the information stream going through any connection via various means (oscilloscope, spectral display, numeric display, etc.)
 * The nesting of nodes (i.e. a node made of another graph of nodes) for the creation of custom DSP routines from basic building blocks without needing to code.
 * Allowing instrument makers to create their own GUIs for their instruments.

== Routing == 
This will work by having each node, implemented as a class, be responsible for asking each of its input nodes for their outputs. As each node needs to process a new input, these calls will pass back along the graph until the beginning of any number of parallel threads is reached.

== DSP blocks ==
Ideally, we would like to be able to edit code right in the main Nuclear application, and having Nuclear handle compilation and loading of dynamic modules. Alternatively, DSP processors can be made by using combinations of any other node, and saved as a node itself. This will likely be implemented more at the interface level than at the application level, as composite nodes are really just a form of clever information management.

== Controllers ==
The idea here is for the nodes to be able to access and use external data, provided by the mother application, as atomic units. This will allow the coding of nodes that can implement new user-level features of any particular synthesizer and/or sampler. This can likely be done by the mother application passing a pointer containing the current value of the required external control to the node when the instrument creator sets up the connection.

== GUI ==
We're taking a serious look at using [http://wiki.drobilla.net/FlowCanvas FlowCanvas] as an easy method of drawing a graph-based programming GUI.

Viewing signal information would be implemented purely at the interface level, allowing the user to, for example, single-click on a connection to see information pop up in a window, like numeric data, an oscilloscope, or a spectral display. These tools would aid in the design and troubleshooting of new instruments.

== Composite nodes == 
A node can be coded from scratch, or it can be a collection of other nodes.The inputs and outputs of a composite node (there's a nice buzzword for you) would be determined simply by which of its internal nodes' connections aren't hooked up to anything internally. That way, a composite node can be treated simply as a single node in an instrument design. This can be accomplished purely at the interface level. At the graph level, it's really just more nodes getting plugged in. The composite nodes represent some real power, as new DSP blocks can be created from existing ones, whether basic or composite themselves. So, basic blocks such as adders, multipliers, and delay lines can be implemented as base nodes, and used to build more complex processors.

== Engine GUI ==
We've discussed the idea of using Cairo to allow users to build custom interfaces for their instruments. Not much else has been said at this point. This and other pages on the subject will be updated/created as more decisions are made.

= Example Projects =

Example projects to be built with Nuclear serving as test cases:

 * Simple polyphonic synth -- The simplest possible test case. Create a simple polyphonic synth with a LFO modulated oscillator.
 * SFZ sample player -- Advanced test case. Require streaming sample playback.
 * Reaktor like application -- Similar to the origianl Nuclear plan but without the need for compilation by GCC to build instruments. Let the user create and edit a processing graph, use a prebuilt standard library of blocks and write new interpreted DSP blocks.
 * Guitar Rig like application -- Not an instrument, but an amplifier/cabinet simulator and effect rack. Test case for modeling of non-linear behavior.