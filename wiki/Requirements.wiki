#summary Project vision and requirements.
#labels Phase-Requirements

= Background = 

The Nuclear project sprung from a discussion over at the [https://bb.linuxsampler.org/viewtopic.php?f=5&t=101 LinuxSampler forum].

Nuclear is neither a synthesizer nor a sampler. It's beyond that. Instead it let you define new synthesizers, samplers and effects which is called _engines_ that it will provide hosting for. The vision is to give virtual instrument makers and plugin developers a powerful tool to create instruments without being limited by a single synthesizer/sample player or bogged down in implementation details common to all virtual instruments.

Originally the idea was to create a single integrated application that both engine creators and end-users would use. An engine maker would use the built in GUI editors to create DSP blocks and connect them together in a processing graph. The DSP and processor graph declarations would be stored in platform independent formats. When a user loaded the engine all the DSP declarations would be compiled natively as modules and the processing graph would be built dynamically from the engine declaration file. This would require the end user having GCC installed and properly configured to be used by the application.

The revised idea is to create a framework to generate code from DSP and engine declarations that will be compiled and linked as a native library. The intended audience is developers who wish to create sample players, synthesizers and effects using a declarative method. To the end-user all hosts and engines appear and are used just like regular applications or plugins.

= Required Features =

 * Being able to create pure software synthesizers, sample players as well as effects and filters.
 * Output the engine as a:
 ** JACK application
 ** Python module
 ** DSSI plugin
 ** LV2 plguin
 ** VST/VSTi plugin
 ** Audio Unit plguin
 ** RTAS plugin.
 * Easy creation of engines by interconnecting basic DSP blocks as nodes in a processing graph.
 * Oversampling of local portions of the graph
 * The ability to create new DSP blocks using FAUST, C++ or any other preferred language.
 * Nodes of the engine have read-access external control data, such as MIDI data or the master clock via messages.
 * The ability to view the information stream going through any connection via various means (oscilloscope, spectral display, numeric display, etc.)
 * The nesting of nodes (i.e. a node made of another graph of nodes) for the creation of custom DSP routines from basic building blocks without needing to code.
 * Allowing instrument makers to create their own GUIs for their instruments.

= Example Projects =

Example projects to be built with Nuclear serving as test cases:

 * Simple polyphonic synth -- The simplest possible test case. Create a simple polyphonic synth with a LFO modulated oscillator.
 * SFZ sample player -- Advanced test case. Require streaming sample playback.
 * Reaktor like application -- Similar to the origianl Nuclear plan but without the need for compilation by GCC to build instruments. Let the user create and edit a processing graph, use a prebuilt standard library of blocks and write new interpreted DSP blocks.
 * Guitar Rig like application -- Not an instrument, but an amplifier/cabinet simulator and effect rack. Test case for modeling of non-linear behavior.